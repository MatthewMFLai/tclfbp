proc global_init {} {
	global g_cids
    global g_cid_node_map
    global g_node_state

    set g_cids ""
	array set g_cid_node_map {}
	array set g_node_state {}
	return
}

# socket server section
proc server_accept {cid addr port} {
	global g_cids

	lappend g_cids $cid
    fileevent $cid readable "server_handle $cid"
    fconfigure $cid -buffering line

	puts $cid "IDENT"
	flush $cid
}

proc server_handle {cid} {
    global g_cids
    global g_cid_node_map
    global g_node_state
	global forever
	global g_result

    if {[gets $cid request] < 0} {
		set idx [lsearch $g_cids $cid]
		if {$idx != -1} {
			set g_cids [lreplace $g_cids $idx $idx]
		}
		if {[info exists g_cid_node_map($cid)]} {
			set tmpnode $g_cid_node_map($cid)
			unset g_cid_node_map($cid)
			unset g_node_state($tmpnode)
		}

		if {![llength $g_cids]} {
			set forever 1
			set g_result "pass"
		}

    } else {
		# Custom code to handle initialization.
		#
		set cmd [lindex $request 0]
		set data [lindex $request 1]
		set response ""
		set state ""
		if {[info exists g_cid_node_map($cid)]} {
			set node $g_cid_node_map($cid)
			set state $g_node_state($node)
		}	

		switch -- $cmd \
			IDENT {
				set g_cid_node_map($cid) $data
				set g_node_state($data) INIT
				puts $cid INIT
				flush $cid

		}   INIT {
				if {$state == "INIT"} {
					set g_node_state($node) ENABLE 
					puts $cid ENABLE 
					flush $cid
				}
					
		}   ENABLE {
				if {$state == "ENABLE"} {
					set g_node_state($node) TESTEND 
				}

		}   TESTEND {
				if {$state == "TESTEND"} {
					set g_node_state($node) SHUTDOWN
					puts $cid SHUTDOWN
					flush $cid
					
					foreach to_cid $g_cids {
						if {$to_cid == $cid} {
							continue
						}
						set node $g_cid_node_map($to_cid)
						set g_node_state($node) SHUTDOWN 
						puts $to_cid SHUTDOWN 
						flush $to_cid
					}
				}

		}   default {

		}
	}
}

package require tcltest
namespace import ::tcltest::*

workingDirectory $env(DISK2)/sharedmem/tcl/node/test

test tc-1.1 {test 2 node setup} -setup {

global_init

load $env(TCLSHAREDMEM)/tclsharedmem.so tclsharedmem
source $env(DISK2)/sharedmem/tcl/msgdef/msgdef.tcl
source $env(DISK2)/sharedmem/tcl/blk_helper/blk_helper.tcl
source $env(DISK2)/sharedmem/tcl/key_helper/key_helper.tcl

Msgdef::Init
Blk_helper::Init
Key_helper::Init /tmp

set compdir $env(COMP_HOME)/company/test1
set keys ""

set fd [open $compdir/test1.node r]
while {[gets $fd line] > -1} {
    set nodename [lindex $line 0]
    set compfile [subst [lindex $line 1]]
    set compname [Blk_helper::Parse $compfile]
    Blk_helper::Add_node $nodename $compname
}
close $fd


set fd [open $compdir/test1.link r]
while {[gets $fd line] > -1} {
    set fromname [lindex $line 0]
    set toname [lindex $line 2]
    set fromport [lindex $line 1]
    set toport [lindex $line 3]
    set fifo_len [lindex $line 4]

    set frommsgname [Blk_helper::Get_port_msgdef $fromname 0 $fromport]
    set tomsgname [Blk_helper::Get_port_msgdef $toname 1 $toport]
    if {$frommsgname != $tomsgname} {
        puts "$line not professed for incompatible msgdef $frommsgname vs $tomsgname"
        continue
    }

    set msgname [Msgdef::Parse $tomsgname]
    set size [Msgdef::Get_Max_Size $msgname]

    set key [Key_helper::Create_key $line]
    Blk_helper::Add_fifo_len $fromname 0 $fromport $key $fifo_len $size
    Blk_helper::Add_fifo_len $toname 1 $toport $key $fifo_len $size
    lappend keys $key
}
close $fd

array set msgattr {}
Msgdef::Get_Attr_Offset $msgname msgattr

set size [Msgdef::Get_Max_Size $msgname] 
set len 4 
queue_init
port_mgr_init

#port_mgr_add out1 $size
#port_mgr_add out2 $size

# Allocate the sharedmem with the key reference.
foreach token [Blk_helper::Get_keys] {
    set key [lindex $token 0]
    set len [lindex $token 1]
    set size [lindex $token 2]

    stub_init $key $len $size 
    stub_clear $key $len $size
}

set sd [socket -server server_accept 8000]

} -body {

foreach node [Blk_helper::Get_nodes] {
    set cmd "exec tclsh $env(DISK2)/sharedmem/tcl/node/node.tcl BLOCK $node INIT localhost:8000 "
    append cmd [Blk_helper::Gen_str $node]
    append cmd " RUNNING 0 &"
    eval $cmd
}

vwait forever
global g_result 
set g_result 

} -cleanup {

    Key_helper::Delete_all_keys

} -result {pass}

cleanupTests
