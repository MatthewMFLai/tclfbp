#
# A client of the echo service.
#

proc Echo_Client {host port} {
    set s [socket $host $port]
    fconfigure $s -buffering line
    return $s
}

# Admin_Server --
#	Open the server listening socket
#	and enter the Tcl event loop
#
# Arguments:
#	port	The server's port number

proc Admin_Server {port} {
    set s [socket -server Admin_Accept $port]
	return $s
}

# Admin_Accept --
#	Accept a connection from a new client.
#	This is called after a new socket connection
#	has been created by Tcl.
#
# Arguments:
#	sock	The new socket connection to the client
#	addr	The client's IP address
#	port	The client's port number
	
proc Admin_Accept {sock addr port} {
    global g_data

    # Record the client's information

    puts "Admin: Accept $sock from $addr port $port"
    set g_data(admin_sock) $sock 

    # Ensure that each "puts" by the server
    # results in a network transmission

    fconfigure $sock -buffering line

    # Set up a callback for when the client sends data

    fileevent $sock readable [list Admin_Handle $sock]
}

# Admin_Handle --
#	This procedure is called when the server
#	can read data from the client
#
# Arguments:
#	sock	The socket connection to the client

proc Admin_Handle {sock} {
	global g_data

    # Check end of file or abnormal connection drop,
    # then echo data back to the client.

    if {[eof $sock] || [catch {gets $sock resp}]} {
		close $sock
    } else {
		if {$resp == "sock rx connected"} {
			set cmd [list KEYS $g_data(id) "$g_data(key):$g_data(size):4"]
			puts $sock $cmd
			flush $sock
		} elseif {$resp == "KEYS $g_data(id) OK"} {
			set g_data(check_state) "CHECK_KEY_OK"
		}
        #
        #
        #
    }
}
#--------------------------------------------------

proc checkagain {} {
    global g_data
    global forever

    array set msgattr {}
    Msgdef::Get_Attr_Offset $g_data(msgname) msgattr

    if {$g_data(check_state) == "CHECK_KEY_OK"} {
        if {$g_data(admin_sock) != ""} {
            set g_data(sd) [Echo_Client localhost $g_data(remoteport)]
            puts $g_data(sd) "$g_data(id) $g_data(key)"
            set g_data(check_state) "CHECK_FIRST_ACK"
        }

    } elseif {$g_data(check_state) == "CHECK_FIRST_ACK"} {
        gets $g_data(sd) line
        if {$line == "$g_data(id) $g_data(key) OK"} {

            array set msgdata {}
            Msgdef::Factory $g_data(msgname) msgdata
            set msgdata(f1) 11111111
            set msgdata(f2) 22222222 
            set msgdata(f3) 33333333 
            set msgdata(f4) 44444444 
            foreach idx [array names msgdata] {
                port_mgr_msg_set out1 $msgdata($idx) $msgattr($idx)
            }
            unset msgdata

            key_mgr_set_buff $g_data(key) [port_mgr_get_msg out1]
            set bcd_msg [key_mgr_bcd_get $g_data(key)]
            puts $g_data(sd) $bcd_msg
            set g_data(bcd_msg) $bcd_msg 

            set g_data(check_state) "CHECK_FIRST_BCD_MSG"
        } else {   
            set forever fail 
            set g_data(check_state) "CHECK_TERMINATE"
		}

    } elseif {$g_data(check_state) == "CHECK_FIRST_BCD_MSG"} {
            gets $g_data(sd) line
            sv_csr_read_wrapper $g_data(key) [port_mgr_get_msg out1]
            key_mgr_set_buff $g_data(key) [port_mgr_get_msg out1]
            set bcd_msg [key_mgr_bcd_get $g_data(key)]
            if {$bcd_msg == $g_data(bcd_msg)} {
                puts "bcd msg 1 matched"
            } else {
                puts "bcd msg 1 did not match"
                puts "send: $g_data(bcd_msg)"
                puts "get : $bcd_msg"
            }

            array set msgdata {}
            Msgdef::Factory $g_data(msgname) msgdata
            set msgdata(f1) eeeeeeee 
            set msgdata(f2) ffffffff 
            set msgdata(f3) gggggggg 
            set msgdata(f4) hhhhhhhh 
            foreach idx [array names msgdata] {
                port_mgr_msg_set out1 $msgdata($idx) $msgattr($idx)
            }
            unset msgdata

            key_mgr_set_buff $g_data(key) [port_mgr_get_msg out1]
            set bcd_msg [key_mgr_bcd_get $g_data(key)]
            puts $g_data(sd) $bcd_msg
            set g_data(bcd_msg) $bcd_msg 

            set g_data(check_state) "CHECK_SECOND_BCD_MSG"

    } elseif {$g_data(check_state) == "CHECK_SECOND_BCD_MSG"} {
            gets $g_data(sd) line
            sv_csr_read_wrapper $g_data(key) [port_mgr_get_msg out1]
            key_mgr_set_buff $g_data(key) [port_mgr_get_msg out1]
            set bcd_msg [key_mgr_bcd_get $g_data(key)]
            if {$bcd_msg == $g_data(bcd_msg)} {
                puts "bcd msg 2 matched"
            } else {
                puts "bcd msg 2 did not match"
                puts "send: $g_data(bcd_msg)"
                puts "get : $bcd_msg"
            }

            array set msgdata {}
            Msgdef::Factory $g_data(msgname) msgdata
            set msgdata(f1) 55555555 
            set msgdata(f2) 66666666 
            set msgdata(f3) 77777777 
            set msgdata(f4) 88888888 
            foreach idx [array names msgdata] {
                port_mgr_msg_set out1 $msgdata($idx) $msgattr($idx)
            }
            unset msgdata

            key_mgr_set_buff $g_data(key) [port_mgr_get_msg out1]
            set bcd_msg [key_mgr_bcd_get $g_data(key)]
            puts $g_data(sd) $bcd_msg
            set g_data(bcd_msg) $bcd_msg 

            set g_data(check_state) "CHECK_THIRD_BCD_MSG"


    } elseif {$g_data(check_state) == "CHECK_THIRD_BCD_MSG"} {
            gets $g_data(sd) line
            sv_csr_read_wrapper $g_data(key) [port_mgr_get_msg out1]
            key_mgr_set_buff $g_data(key) [port_mgr_get_msg out1]
            set bcd_msg [key_mgr_bcd_get $g_data(key)]
            if {$bcd_msg == $g_data(bcd_msg)} {
                puts "bcd msg 3 matched"
            } else {
                puts "bcd msg 3 did not match"
                puts "send: $g_data(bcd_msg)"
                puts "get : $bcd_msg"
            }

			puts $g_data(admin_sock) "KEYS-REMOVE $g_data(id) $g_data(key)"

            set g_data(check_state) "CHECK_WAIT_MORE"

    } elseif {$g_data(check_state) == "CHECK_WAIT_MORE"} {
            set forever pass 
            set g_data(check_state) "CHECK_TERMINATE"

    } 
    if {$g_data(check_state) != "CHECK_TERMINATE"} {
        after 100 checkagain
    }
}

package require tcltest
namespace import ::tcltest::*

workingDirectory $env(DISK2)/sharedmem/tcl/node/test

test tc-1.1 {test sock node rx path} -setup {

load $env(TCLSHAREDMEM)/tclsharedmem[info sharedlibextension] tclsharedmem
source $env(DISK2)/sharedmem/tcl/msgdef/msgdef.tcl
source $env(DISK2)/sharedmem/tcl/blk_helper/blk_helper.tcl
source $env(DISK2)/sharedmem/tcl/key_helper/key_helper.tcl

Msgdef::Init
Key_helper::Init /tmp

set compdir $env(COMP_HOME)/test
set keys ""
set id "graph1"
set msgname [Msgdef::Parse $env(COMP_HOME)/msgdef/test/test0.msg]
set size [Msgdef::Get_Max_Size $msgname]
set key [Key_helper::Create_key $id "test-key"]
puts "key = $key"
set len 4 

array set msgattr {}
Msgdef::Get_Attr_Offset $msgname msgattr

queue_init
port_mgr_init
key_mgr_init

key_mgr_add $key $size
port_mgr_add out1 $size

stub_init $key $len $size 
stub_clear $key $len $size

array set g_data {id graph1 admin_sock "" remoteport 14000}
set g_data(msgname) $msgname
set g_data(check_state) "CHECK_ADMIN_SOCK"
set g_data(key) $key
set g_data(size) $size
set g_data(remoteport) 14000
set g_data(bcd_msg) ""
set hostport 13000
set remoteport 14000
set g_admin_sd [Admin_Server $hostport]
exec tclsh $env(DISK2)/sharedmem/tcl/node/sock_node_rx.tcl INIT localhost:$hostport RX_PORT $remoteport &
 
} -body {

after idle checkagain
vwait forever
global forever
set forever

} -cleanup {

stub_cleanup $key
Key_helper::Delete_all_keys $id

} -result {pass}

cleanupTests
