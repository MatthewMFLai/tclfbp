# Echo_Server --
#	Open the server listening socket
#	and enter the Tcl event loop
#
# Arguments:
#	port	The server's port number

proc Echo_Server {port} {
    global g_count

    set g_count 0
    set s [socket -server EchoAccept $port]
}

# Echo_Accept --
#	Accept a connection from a new client.
#	This is called after a new socket connection
#	has been created by Tcl.
#
# Arguments:
#	sock	The new socket connection to the client
#	addr	The client's IP address
#	port	The client's port number
	
proc EchoAccept {sock addr port} {
    global echo

    # Record the client's information

    puts "Accept $sock from $addr port $port"
    set echo(addr,$sock) [list $addr $port]

    # Ensure that each "puts" by the server
    # results in a network transmission

    fconfigure $sock -buffering line

    # Set up a callback for when the client sends the shared
    # memory key data. 

    fileevent $sock readable [list EchoMatchKey $sock]
}

# EchoMatchKey --
#	This procedure is called when the server
#	reads the very first data line from the client
#       containing the shared memory key name.
#
# Arguments:
#	sock	The socket connection to the client

proc EchoMatchKey {sock} {

    # Check end of file or abnormal connection drop,
    # then echo data back to the client.

    if {[eof $sock] || [catch {gets $sock line}]} {
	close $sock
    } else {
        # Echo line back for now.
        puts $sock $line
        fileevent $sock readable [list Echo $sock]
    }
}

# Echo --
#	This procedure is called when the server
#	can read data from the client
#
# Arguments:
#	sock	The socket connection to the client

proc Echo {sock} {
    global echo
    global forever
    global g_count
    global g_bcd_msg_list
    global g_admin_sock 

    # Check end of file or abnormal connection drop,
    # then echo data back to the client.

    if {[eof $sock] || [catch {gets $sock line}]} {
	close $sock
	puts "Close $echo(addr,$sock)"
	unset echo(addr,$sock)
    } else {
        set src_line [lindex $g_bcd_msg_list $g_count]
        if {$src_line == $line} {
            puts "test msg $g_count matched"
        } else {
            puts "test msg $g_count not matched"
            puts "src line: $src_line"
            puts "rxd line: $line"
        }
	puts $sock $line
        incr g_count
        if {$g_count == 3} {
            close $g_admin_sock
            set forever pass 
        }
    }
}

# Admin_Server --
#	Open the server listening socket
#	and enter the Tcl event loop
#
# Arguments:
#	port	The server's port number

proc Admin_Server {port} {
    set s [socket -server Admin_Accept $port]
}

# Admin_Accept --
#	Accept a connection from a new client.
#	This is called after a new socket connection
#	has been created by Tcl.
#
# Arguments:
#	sock	The new socket connection to the client
#	addr	The client's IP address
#	port	The client's port number
	
proc Admin_Accept {sock addr port} {
    global g_admin_sock 

    # Record the client's information

    puts "Accept $sock from $addr port $port"
    set g_admin_sock $sock 

    # Ensure that each "puts" by the server
    # results in a network transmission

    fconfigure $sock -buffering line

    # Set up a callback for when the client sends data

    fileevent $sock readable [list Admin_Handle $sock]
}

# Admin_Handle --
#	This procedure is called when the server
#	can read data from the client
#
# Arguments:
#	sock	The socket connection to the client

proc Admin_Handle {sock} {

    # Check end of file or abnormal connection drop,
    # then echo data back to the client.

    if {[eof $sock] || [catch {gets $sock line}]} {
	close $sock
    } else {
        #
        #
        #
    }
}
#--------------------------------------------------

package require tcltest
namespace import ::tcltest::*

workingDirectory $env(DISK2)/sharedmem/tcl/node/test

test tc-1.1 {test sock node tx path} -setup {

load $env(TCLSHAREDMEM)/tclsharedmem.so tclsharedmem
source $env(DISK2)/sharedmem/tcl/msgdef/msgdef.tcl
source $env(DISK2)/sharedmem/tcl/blk_helper/blk_helper.tcl
source $env(DISK2)/sharedmem/tcl/key_helper/key_helper.tcl

Msgdef::Init
Key_helper::Init /tmp

set compdir $env(COMP_HOME)/test
set keys ""

set msgname [Msgdef::Parse $env(COMP_HOME)/msgdef/test/test0.msg]
set size [Msgdef::Get_Max_Size $msgname]
set key [Key_helper::Create_key "test-key"]
puts "key = $key"
set len 4 

array set msgattr {}
Msgdef::Get_Attr_Offset $msgname msgattr

queue_init
port_mgr_init
key_mgr_init

key_mgr_add $key $size
port_mgr_add out1 $size

stub_init $key $len $size 
stub_clear $key $len $size

set g_bcd_msg_list ""

after 2000 {
array set msgdata {}
Msgdef::Factory $msgname msgdata
set msgdata(f1) 11111111
set msgdata(f2) 22222222 
set msgdata(f3) 33333333 
set msgdata(f4) 44444444 
foreach idx [array names msgdata] {
    port_mgr_msg_set out1 $msgdata($idx) $msgattr($idx)
}
unset msgdata

key_mgr_set_buff $key [port_mgr_get_msg out1]
lappend g_bcd_msg_list [key_mgr_bcd_get $key]
sv_csr_write_wrapper $key [port_mgr_get_msg out1]

}

after 3000 {
array set msgdata {}
Msgdef::Factory $msgname msgdata
set msgdata(f1) eeeeeeee 
set msgdata(f2) ffffffff 
set msgdata(f3) gggggggg 
set msgdata(f4) hhhhhhhh 
foreach idx [array names msgdata] {
    port_mgr_msg_set out1 $msgdata($idx) $msgattr($idx)
}
unset msgdata

key_mgr_set_buff $key [port_mgr_get_msg out1]
lappend g_bcd_msg_list [key_mgr_bcd_get $key]
sv_csr_write_wrapper $key [port_mgr_get_msg out1]
}

after 4000 {
array set msgdata {}
Msgdef::Factory $msgname msgdata
set msgdata(f1) 55555555 
set msgdata(f2) 66666666 
set msgdata(f3) 77777777 
set msgdata(f4) 88888888 
foreach idx [array names msgdata] {
    port_mgr_msg_set out1 $msgdata($idx) $msgattr($idx)
}
unset msgdata

key_mgr_set_buff $key [port_mgr_get_msg out1]
lappend g_bcd_msg_list [key_mgr_bcd_get $key]
sv_csr_write_wrapper $key [port_mgr_get_msg out1]
}

set hostport 13000
set remoteport 14000
Admin_Server $hostport 
Echo_Server $remoteport
 
} -body {

exec tclsh $env(DISK2)/sharedmem/tcl/node/sock_node.tcl INIT localhost:$hostport KEYS "localhost:0:localhost:$remoteport:$key:$size:4" &
vwait forever
global forever
set forever

} -cleanup {

stub_cleanup $key
Key_helper::Delete_all_keys

} -result {pass}

cleanupTests
